---
title: "Análisis de datos espaciales en R"
subtitle: "Manejo de datos espaciales en R"
author: "Diego Nieto Lugilde"
institute: "Universidad de Córdoba (España)"
slide-number: true
format:
  revealjs:
    logo: img/logos.png
    footer: "[AEMeR](https://dnietolugilde.com/AEMeR)"
    scrollable: true
    chalkboard: true
    transition: slide
editor: source
---

## ¿Qué son los datos espaciales?

![](img/datos_espaciales.jpg)

## La misma información se puede representar de varias maneras

:::: {.columns}

::: {.column}
Algunos tipos de datos se ajustan mejor que otros a ciertas formas de representarlos
:::

::: {.column}
![](img/raster_versus_vectorial.jpg)
:::

::::

## ¿Cómo se localiza la información?

![](img/coordenadas-geograficas.jpg)

## No parece fácil medir los ángulos ;)

![](img/datum.jpg)

Se calculan aproximaciones usando modelos de la Tierra (Datum)

## Además, no es lo mismo saber donde ocurre algo que dibujar un mapa

:::: {.columns}

::: {.column width="40%"}
Para ello es necesario proyectar una esfera sobre un plano
:::

::: {.column width="60%"}
![](img/proyecciones.png)
:::

::::

## Cada proyección y cada datum genera mapas con propiedades diferentes

![](img/tipos_de_proyecciones.jpg)

# Manejando datos espaciales {background-color="aquamarine"}

## Para ello usaremos el paquete Terra

```{r}
#| echo: true
library(terra)
```

# Manejando datos vectoriales {background-color="aquamarine"}

## Crear datos vectoriales desde cero

```{r}
#| echo: true
#| code-line-numbers: '1-2|3|4-5'
lon <- c(-116.7, -120.4, -116.7, -113.5, -115.5, -120.8, -119.5, -113.7, -113.7, -110.7) 
lat <- c(45.3, 42.6, 38.9, 42.1, 35.7, 38.9, 36.2, 39, 41.6, 36.9) 
lonlat <- cbind(lon, lat) 
pts <- vect(lonlat) 
pts
```

::: asides
Fijaros que el apartado "coord. ref." está vacío.
:::

## Revisamos el tipo de datos

```{r}
#| echo: true
class (pts)
```

```{r}
#| echo: true
geom(pts)
```

## Visualizamos la distribución espacial de los datos

```{r}
#| echo: true
plot(pts)
```

## Establecemos el sistema de referencia de coordenadas (CRS)

```{r}
#| echo: true
crdref <- "+proj=longlat +datum=WGS84"
pts <- vect(lonlat, crs = crdref)
pts
```

## Podemos comprobar sólo el CRS de un archivo vectorial

```{r}
#| echo: true
crs(pts)
```

## La ubicación sola no es muy interesante...

Vamos a simular valores de precipitación al azar, un valor para cada punto.

```{r}
#| echo: true
precipvalue <- sample(1:100, 10)
df <- data.frame(ID = 1:nrow(lonlat), precip = precipvalue)
pts <- vect(lonlat, atts = df, crs = crdref)
pts
```

## Visualizamos las precipitaciones en su contexto espacial

```{r}
#| echo: true
plot(pts, "precip", type = "interval")
```

## Vamos a generar ahora un segundo conjunto de puntos...

```{r}
#| echo: true
lon2 <- c(-116.8, -114.2, -112.9, -111.9, -114.2, -115.4, -117.7)
lat2 <- c(41.3, 42.9, 42.4, 39.8, 37.6, 38.3, 37.6)
lonlat2 <- cbind(id = c(1,1,1,1,1,1,1), part = c(1,1,1,1,1,1,1), lon2, lat2)
lonlat2
```

## ... pero para crear datos vectoriales de líneas...

```{r}
#| echo: true
lns <- vect(lonlat2, type = "lines", crs = crdref)
lns
```

```{r}
#| echo: true
plot(lns)
```

## ... o un datos vectoriales de polígonos.

```{r}
#| echo: true

pols <- vect(lonlat2, type = "polygons", crs = crdref)
pols
```

```{r}
#| echo: true

plot(pols)
```

## Lo más normal es usar datos generados con un SIG.

Podemos descargar datos de internet (v.gr. [GADM](https://gadm.org)) y cargarlos desde nuestro disco duro.

```{r}
#| echo: true
#| eval: false

# install.packages("geodata")
arg <- vect("gadm/gadm41_ARG_1.shp")
arg
```

## Lo más normal es usar datos generados con un SIG.

Pero hay paquetes que dan acceso a datos vectoriales directamente en R (v.gr. `geodata`)

```{r}
#| echo: true

# install.packages("geodata")
library(geodata)
arg <- gadm("ARG", level = 1, path = ".")
arg
```

## Veamos si se parece a lo que conocemos...

```{r}
#| echo: true

plot(arg)
```

## Si quieres guardar esos datos para no tener que volver a descargarlos, puedes escribir ficheros vectoriales

```{r}
#| echo: true
#| eval: false

writeVector(arg, "arg.shp", overwrite = TRUE)
```

## Comprobamos el CRS de alguno de nuestros datos

```{r}
#| echo: true

crs(arg)
```

## Se puede borrar el CRS del conjunto de datos

```{r}
#| echo: true

arg_sin_crs <- arg
crs(arg_sin_crs) <- ""
crs(arg_sin_crs)
```

## O se puede especificar a mano (estandar PROJ.4)

```{r}
#| echo: true

arg_falso_utm <- arg
crs(arg_falso_utm) <- "+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs +type=crs"
crs(arg_falso_utm)
```

## O se puede especificar con los códigos [EPSG](https://epsg.io/)

```{r}
#| echo: true

arg_false_utm2 <- arg
crs(arg_false_utm2) <- "EPSG:32719"
crs(arg_false_utm2)
```

## Notad que eso cambia el sistema de referencia pero no las coordenadas en si

```{r}
#| echo: true

par(mfrow = c(2, 2))
plot(arg)
plot(arg_sin_crs)
plot(arg_falso_utm)
plot(arg_false_utm2)
```

## Si queremos convertir coordenadas entre CRS tenemos que proyectar los datos

```{r}
#| echo: true

arg_utm19s <- project(arg, "+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs +type=crs")

arg_4326 <- project(arg, "EPSG:32719")
par(mfrow = c(1, 3))
plot(arg)
plot(arg_utm19s)
plot(arg_4326)
```

## Momento para practicar

Ejercicios de clase

Parte 1: Trabajando con datos vectoriales

# Manejando datos raster {background-color="aquamarine"}

## Crear datos raster

```{r}
#| echo: true

r <- rast(ncol = 10, nrow = 10, 
          xmin = -150, xmax = -80, 
          ymin = 20, ymax = 60)
r
```

```{r}
#| echo: true

values(r) <- runif(ncell(r))
r
```

## Graficar datos raster

```{r}
#| echo: true

plot(r)
```

## Operar con datos raster

```{r}
#| echo: true

r2 <- r * r
r3  <- sqrt(r)
```

## Combinar raster para crear un objeto multicapa

```{r}
#| echo: true

stck <- c(r, r2, r3)
stck
```

## Graficar datos multicapa

```{r}
#| echo: true

plot(stck)
```

## Extraer capas sueltas de objetos multicapa

```{r}
#| echo: true

r2 <- stck[[2]]
r2
```

## Como con datos vectoriales, lo normal es cargar datos ya generados en SIG.

Para ello podemos descargar datos de distintas fuentes (v.gr. [WorldClim](https://worldclim.org))...

```{r}
#| echo: true

tavg <- rast("tavg_arg.tif")
tavg
```

## ... o podemos usar el paquete `geodata` para acceder directamente a esa información

```{r}
#| echo: true
#| eval: false

tavg <- worldclim_country("ARG", "tavg", path = ".")
tavg
```

## Veamos si se parece a lo que conocemos...

```{r}
#| echo: true

plot(tavg, range = c(-20, 30))
```

## Si queremos reutilizar los datos y no tener que volver a descargarlos, también podemos escribirlos en un fichero de datos raster

```{r}
#| echo: true
#| eval: false

writeRaster(tavg_arg.tif, "raster_tavg_arg.tif", overwrite = TRUE)
```

## También se pueden proyectar datos raster

```{r}
#| echo: true
 
tavg_utm19s <- project(tavg, "EPSG:32719")
tavg_utm19s
```

## Ahora si que las coordenadas aparecen "desplazadas"

```{r}
#| echo: true

par(mfrow = c(1, 2))
plot(tavg[[1]])
plot(tavg_utm19s[[1]])
```

::: asides
Notad que no hay una correspondencia exacta de píxeles.
:::

## Para controlar el número de pixeles y su resolución lo normal es crear antes una plantilla

```{r}
#| echo: true

x <- rast(tavg_utm19s)
res(x) <- 800
x
```

```{r}
#| echo: true

tavg_utm19s_2 <- project(tavg, x)
tavg_utm19s_2
```

## Veamos el resultado

```{r}
#| echo: true

par(mfrow = c(1, 3))
plot(tavg[[2]])
plot(tavg_utm19s[[2]])
plot(tavg_utm19s_2[[2]])
```

```{r}
#| echo: true

tavg[[2]]
tavg_utm19s[[2]]
tavg_utm19s_2[[2]]
```

## Momento de practicar por vuestra cuenta

Ejercicios de clase

Parte 2. Manejo de datos raster

# Manipular datos espaciales {background-color="aquamarine"}

## Podemos dibujar los mapas con colores en base a alguna información de los atributos.

```{r}
#| echo: true

plot(arg, "NAME_1")
```

## Podemos combinar información raster y vectorial en el mismo mapa

```{r}
#| echo: true

plot(tavg[[1]])
plot(arg, add = TRUE)
```

## También se puede extraer la información de los atributos en formato `data.frame` para trabajar con ella de forma estadística.

```{r}
#| echo: true

d <- as.data.frame(arg)
head(d)
```

## O puedo extraer la información de un sólo campo de los atributos.

```{r}
#| echo: true

arg$NAME_1
arg[, "NAME_1"]
```

::: asides
Notad que en este caso, las dos formas de extraer información no se comportan exactamente igual.
:::

## También podemos extraer las características geográficas (espaciales)

```{r}
#| echo: true

g <- geom(arg_utm19s) 
head(g)
```

## A veces, necesitamos incorporar información a nuestros datos vectoriales.

```{r}
#| echo: true

arg$lets <- sample(letters, nrow(arg_utm19s)) 
arg
```

```{r}
#| echo: true

perim(arg)
arg$perimetro <- perim(arg)
```

```{r}
#| echo: true

expanse(arg)
arg$area <- expanse(arg)
```

## ¿Qué pasa si quiero borrar una columna?

```{r}
#| echo: true

arg$lets <- NULL
```

## A veces tenemos los datos en una tabla aparte

Podemos vincularla con los datos de los atributos vectoriales, pero necesitamos un campo en común.

Me descargué datos del [censo poblacional del país](https://censo.gob.ar/index.php/datos_definitivos_total_pais/)

```{r}
#| echo: true

d <- read.csv("data/c2022_tp_c_resumen.csv", header = TRUE, encoding = "latin1")
arg <- merge(arg, d, by.x = "NAME_1", by.y = "provincia")
arg
```

## Veamos como se ve la población argentina por provincias...

```{r}
#| echo: true

plot(arg, "poblacion", type = "continuous")
```

## También se puede filtrar la información para una o varias entidades dentro de los datos.

```{r}
#| echo: true

which(arg$NAME_1 == "Buenos Aires")
i <- which(arg$NAME_1 %in% c("Buenos Aires", "Río Negro"))
g <- arg[i,]
plot(g)
```

## A veces necesitamos combinar información de varios polígonos en uno de mayor tamaño

```{r}
#| echo: true

arg_0 <- aggregate(arg, by = "COUNTRY") 
plot(arg_0, col = "white", lwd = 2, border = "cyan")
```

## En los objetos raster también se pueden hacer agregaciones, pero normalmente para cambiar la resolución de los datos

```{r}
#| echo: true

tavg_10 <- aggregate(tavg, fact = 100, fun = "mean", na.rm = TRUE)
par(mfrow = c(1, 2))
plot(tavg[[1]])
plot(tavg_10[[1]])
```

## En otras ocasiones tenemos dos capas vectoriales y necesitamos quedarnos sólo con datos que quedan dentro de una de ellas

```{r}
#| echo: true

clip <- rast(ext = c(-70, -60, -47, -30), nrow = 2, ncol = 2)
values(clip) <- 1:4
names(clip) <- "Zona"
clip <- as.polygons(clip)
clip 
```

```{r}
#| echo: true

plot(arg) 
plot(clip, add = TRUE, border = "blue", lwd = 5) 
```

```{r}
#| echo: true

arg_clip <- intersect(arg, clip) 
plot(arg_clip)
```

## Los objetos raster también se pueden cortar con un vectorial

```{r}
#| echo: true

tavg_arg <- mask(tavg, arg)
par(mfrow = c(1, 2))
plot(tavg[[1]])
plot(tavg_arg[[1]])
```

## Otras veces necesitamos combinar los vectores de dos ficheros diferentes

```{r}
#| echo: true

u <- union(arg, clip)
plot(u, col = sample(rainbow(length(u))))
```

## En estudios de biodiversidad, es muy frecuente necesitar extraer información de una capa vectorial en los puntos, líneas o polígonos de otra capa vectorial

```{r}
#| echo: true

pnts <- spatSample(arg, 100)
```

```{r}
#| echo: true

plot(arg)
plot(clip, add = TRUE, border = "cyan")
plot(pnts, add = TRUE, col = "red")
```

```{r}
#| echo: true

pnts_arg <- extract(arg, pnts)
pnts_arg
```

```{r}
#| echo: true

pnts_clip <- extract(clip, pnts)
pnts_clip
```

## Igual podemos hacer con respecto a los valores de los píxeles en cada punto de un vectorial

```{r}
#| echo: true

pnts_tavg <- extract(tavg, pnts)
pnts_tavg
```

::: asides
Fijaros que extráe un valor de cada capa del raster stack.
:::

## También funciona con polígonos

```{r}
#| echo: true

prov_tavg <- extract(tavg, arg, fun = "mean", bind = TRUE, na.rm = TRUE)
plot(prov_tavg, "ARG_wc2.1_30s_tavg_1")
```

## Los objetos raster se puede operar matemáticamente con ellos para generar estadísticos

En general se puede usar cualquiera de estas funciones: `min`, `max`, `mean`, `prod`, `sum`, `median`, `cv`, `range`, `any` y `all`.

```{r}
#| echo: true

min_tavg <- min(tavg)
plot(min_tavg)
```

## También hay multitud de funciones avanzadas propias de un SIG, tanto para vectoriales como raster

`crop`, `trim`, `merge`, `disagg`, `resample`, `classify` o `cover`

`gdistance` package ofrece análisis de distancias complejos (least cost path, etcétera)

## Last but not least. Se pueden transformar datos vectoriales en raster ...

```{r}
#| echo: true

arg_raster <- rasterize(arg, tavg, field = "NAME_1")
class(arg_raster)
plot(arg_raster)
```

## ... y viceversa

```{r}
#| echo: true

as.polygons(tavg[[1]])

```

## Hora de trabajar por vuestra cuenta...

Ejercicios de clase

Parte 3. Manipulación de datos raster y vectoriales
