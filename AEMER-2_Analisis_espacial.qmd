---
title: "Análisis de datos espaciales en R"
subtitle: "Manejo de datos espaciales en R"
author: "Diego Nieto Lugilde"
institute: "Universidad de Córdoba (España)"
slide-number: true
format:
  revealjs:
    logo: img/logos.png
    footer: "[AEMeR](https://dnietolugilde.com/AEMeR)"
    scrollable: true
    theme: dark
editor: source
---

# Manejando datos espaciales

## Para ello usaremos el paquete Terra

```{r}
#| echo: true
library(terra)
```

# Manejando datos vectoriales

## Crear datos vectoriales desde cero

```{r}
#| echo: true
#| code-line-numbers: '1-2|3|4-5'
lon <- c(-116.7, -120.4, -116.7, -113.5, -115.5, -120.8, -119.5, -113.7, -113.7, -110.7) 
lat <- c(45.3, 42.6, 38.9, 42.1, 35.7, 38.9, 36.2, 39, 41.6, 36.9) 
lonlat <- cbind(lon, lat) 
pts <- vect(lonlat) 
pts
```

::: aside
Fijaros que el apartado "coord. ref." está vacío.
:::

## Revisar

```{r}
#| echo: true
class (pts)
```

```{r}
#| echo: true
geom(pts)
```

## Visualizar

```{r}
#| echo: true
plot(pts)
```

## Establecer sistema de referencia de coordenadas (CRS)

```{r}
#| echo: true
crdref <- "+proj=longlat +datum=WGS84"
pts <- vect(lonlat, crs=crdref)
pts
```

## Podemos comprobar sólo el CRS de un archivo vectorial

```{r}
#| echo: true
crs(pts)
```

## La ubicación sola no es muy interesante...

Vamos a simular valores de precipitación al azar, un valor para cada punto.

```{r}
#| echo: true
precipvalue <- round(runif(nrow(lonlat), min=0, max=100))
df <- data.frame(ID=1:nrow(lonlat), precip=precipvalue)
pts <- vect(lonlat, atts=df, crs=crdref)
pts
```

## Graficar precipitaciones

```{r}
#| echo: true
plot(pts, "precip", type = "interval")
```

## Vamos a genera un segundo conjunto de puntos...

```{r}
#| echo: true
lon2 <- c(-116.8, -114.2, -112.9, -111.9, -114.2, -115.4, -117.7)
lat2 <- c(41.3, 42.9, 42.4, 39.8, 37.6, 38.3, 37.6)
lonlat2 <- cbind(id=c(1,1,1,1,1,1,1), part=c(1,1,1,1,1,1,1), lon2, lat2)
lonlat2
```

## ... pero para crear datos de líneas...

```{r}
#| echo: true
lns <- vect(lonlat2, type="lines", crs=crdref)
lns
```

```{r}
#| echo: true
plot(lns)
```

## ... o un datos de polígonos.

```{r}
#| echo: true
pols <- vect(lonlat2, type="polygons", crs=crdref)
pols
```

```{r}
#| echo: true
plot(pols)
```

## Cargando datos ya existentes

```{r}
#| echo: true

# install.packages("geodata")
library(geodata)
arg <- gadm("ARG", level = 2, path = ".")
arg
```

## Veamos si se parece a lo que conocemos...

```{r}
#| echo: true

plot(arg)
```

## Escribir ficheros vectoriales

```{r}
#| echo: true
#| eval: false

writeVector(arg, "arg.shp", overwrite=TRUE)
```

# Manejando datos raster

## Crear datos raster

```{r}
#| echo: true
r <- rast(ncol=10, nrow=10, xmin=-150, xmax=-80, ymin=20, ymax=60)
r
```

```{r}
#| echo: true
values(r) <- runif(ncell(r))
r
```

## Graficar datos raster

```{r}
#| echo: true
plot(r)
```

## Añadir información vectorial sobre el gráfico

```{r}
#| echo: true
plot(r)
plot(pols, border = "blue", lwd = 2, add = TRUE)
plot(pts, col = "red", pch=20, cex=1, add = TRUE)
```

## Operar con datos raster

```{r}
#| echo: true
r2 <- r * r
r3  <- sqrt(r)
```

## Combinar raster para crear un objeto multicapa

```{r}
#| echo: true
stck <- c(r, r2, r3)
stck
```

## Graficar datos multicapa

```{r}
#| echo: true
plot(stck)
```

## Extraer capas sueltas de objetos multicapa

```{r}
#| echo: true
r2 <- stck[[2]]
r2
```

## Cargar datos raster

```{r}
#| echo: true
#| eval: false

tavg <- geodata::worldclim_country("ARG", "tavg", path = ".")
tavg
```

```{r}
#| echo: false
#| eval: true

tavg <- rast("tavg_arg.tif")
tavg
```
## Veamos si se parece a lo que conocemos...

```{r}
#| echo: true
plot(tavg)
```

## Escribir fichero de datos raster

```{r}
#| echo: true
#| eval: false
writeRaster(tavg_arg.tif, "raster_tavg_arg.tif", overwrite=TRUE)
```

# Proyecciones

## Comprobamos el CRS de alguno de nuestros datos

```{r}
#| echo: true
crs(arg)
```

## Se puede borrar el CRS del conjunto de datos

```{r}
#| echo: true
arg_sp <- arg
crs(arg_sp) <- ""
crs(arg_sp)
```

## O se puede especificar a mano (estandar PROJ.4)

```{r}
#| echo: true

arg_falso_utm <- arg
crs(arg_falso_utm) <- "+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs +type=crs"
crs(arg_falso_utm)
```

## O se puede especificar con los códigos EPSG

```{r}
#| echo: true
arg_false_utm2 <- arg
crs(arg_false_utm2) <- "EPSG:32719"
crs(arg_false_utm2)
```

## Notad que eso cambia el sistema de referencia pero no las coordenadas en si

```{r}
#| echo: true
par(mfrow = c(2, 2))
plot(arg)
plot(arg_sp)
plot(arg_falso_utm)
plot(arg_false_utm2)
```

## Si queremos convertir coordenadas entre CRS tenemos que proyectar los datos

```{r}
#| echo: true

arg_utm19s <- terra::project(arg, "+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs +type=crs")

arg_4326 <- terra::project(arg, "EPSG:32719")
par(mfrow=c(1, 3))
plot(arg)
plot(arg_utm19s)
plot(arg_4326)
```

## También se pueden proyectar datos raster

```{r}
#| echo: true
#| 
tavg_utm19s <- terra::project(tavg, "EPSG:32719")
tavg_utm19s
```

## Ahora si que las coordenadas aparecen "desplazadas"

```{r}
#| echo: true
par(mfrow = c(1, 2))
plot(tavg[[1]])
plot(tavg_utm19s[[1]])
```

::: asides
Notad que los píxeles no tienen un tamaño regular
:::

## Para controlar el número de pixeles y su resolución debemos crear antes una plantilla

```{r}
#| echo: true
x <- rast(tavg_utm19s)
res(x) <- 500
x
```

```{r}
#| echo: true

tavg_utm19s_2 <- terra::project(tavg_utm19s, x)
tavg_utm19s_2
```

## Veamos el resultado

```{r}
#| echo: true
par(mfrow = c(1, 3))
plot(tavg[[2]])
plot(tavg_utm19s[[2]])
plot(tavg_utm19s_2[[2]])
```

```{r}
#| echo: true
tavg[[2]]
tavg_utm19s[[2]]
tavg_utm19s_2[[2]]
```
# Manipular datos espaciales

plot(arg, "NAME_2")

d <- as.data.frame(arg) 

head(d)

g <- geom(arg) head(g)

g <- geom(arg, wkt=TRUE) substr(g, 1, 50)

arg$NAME_2

arg[, "NAME_2"]

set.seed(0) arg$lets <- sample(letters, nrow(arg)) arg

perim(arg) arg$perimetro <- perim(arg)

arg\$lets \<- sample(LETTERS, nrow(arg)) head(arg)

arg\$lets \<- NULL

dfr \<- data.frame(District = arg$NAME_1, Canton = arg$NAME_2, Value = round(runif(length(arg), 100, 1000))) dfr \<- dfr\[order(dfr\$Canton), \] pm \<- merge(arg, dfr, by.x = c('NAME_1', 'NAME_2'), by.y = c('District', 'Canton')) pm

head(pm)

i \<- which(p\$NAME_1 == 'Grevenmacher') g \<- p\[i,\] g

z \<- rast(p) dim(z) \<- c(2,2) values(z) \<- 1:4 names(z) \<- 'Zone'

z \<- as.polygons(z) z

z2 \<- z\[2,\] plot(p) plot(z, add=TRUE, border='blue', lwd=5) plot(z2, add=TRUE, border='red', lwd=2, col='red')

b \<- rbind(p, z) head(b)

tail(b)

pa \<- aggregate(p, by='NAME_1') za \<- aggregate(z) plot(za, col='light gray', border='light gray', lwd=5) plot(pa, add=TRUE, col=rainbow(3), lwd=3, border='white')

e \<- erase(p, z2) plot(e)

i \<- intersect(p, z2) plot(i)

e \<- ext(6, 6.4, 49.7, 50) pe \<- crop(p, z2) plot(p) plot(e, add=TRUE, lwd=3, col="red") plot(i, col='light green', add=TRUE) plot(pe, col='light blue', add=TRUE) plot(e, add=TRUE, lwd=3, border="blue")

u \<- union(p, z) u

set.seed(5) plot(u, col=sample(rainbow(length(u))))

dif \<- symdif(z,p) plot(dif, col=rainbow(length(dif)))

extract(spts, p)

extract(spts, z)
