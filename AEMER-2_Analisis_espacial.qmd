---
title: "Análisis de datos espaciales en R"
subtitle: "Manejo de datos espaciales en R"
author: "Diego Nieto Lugilde"
institute: "Universidad de Córdoba (España)"
slide-number: true
editor: source
format:
  revealjs:
    scrollable: true
    theme: dark
---

![](img/logos.png){width=100%}

# Manejando datos vectoriales

## Crear datos vectoriales desde cero

```{r}
#| echo: true
#| code-line-numbers: '3-4|5|6-7'
library(terra)

lon <- c(-116.7, -120.4, -116.7, -113.5, -115.5, -120.8, -119.5, -113.7, -113.7, -110.7) 
lat <- c(45.3, 42.6, 38.9, 42.1, 35.7, 38.9, 36.2, 39, 41.6, 36.9) 
lonlat <- cbind(lon, lat) 
pts <- vect(lonlat) 
pts
```

::: aside
Fijaros que el apartado "coord. ref." está vacío.
:::

## Revisar

```{r}
#| echo: true
class (pts)
```

```{r}
#| echo: true
geom(pts)
```

## Visualizar

```{r}
#| echo: true
plot(pts)
```

## Establecer sistema de referencia de coordenadas (CRS)

```{r}
#| echo: true
crdref <- "+proj=longlat +datum=WGS84"
pts <- vect(lonlat, crs=crdref)
pts
```

## Podemos comprobar sólo el CRS de un archivo vectorial

```{r}
#| echo: true
crs(pts)
```

## La ubicación sola no es muy interesante...

Vamos a generar a simular valores de precipitación al azar, un valor para cada punto.

```{r}
#| echo: true
precipvalue <- round(runif(nrow(lonlat), min=0, max=100))
df <- data.frame(ID=1:nrow(lonlat), precip=precipvalue)
pts <- vect(lonlat, atts=df, crs=crdref)
pts
```

## Graficar precipitaciones

```{r}
#| echo: true
plot(pts, cex = precip/10)
```

## Genera un segundo conjunto de puntos...

```{r}
#| echo: true
lon2 <- c(-116.8, -114.2, -112.9, -111.9, -114.2, -115.4, -117.7)
lat2 <- c(41.3, 42.9, 42.4, 39.8, 37.6, 38.3, 37.6)
lonlat2 <- cbind(id=c(1,1,1,1,1,1,1), part=c(1,1,1,1,1,1,1), lon2, lat2)
lonlat2
```

## ... para crear un conjunto de datos de líneas...

```{r}
#| echo: true
lns <- vect(lonlat2, type="lines", crs=crdref)
lns
```

## ... o para generar un conjunto de datos de polígonos.

```{r}
#| echo: true
pols <- vect(lonlat2, type="polygons", crs=crdref)
pols
```

## Cargando datos ya existentes

```{r}
#| echo: true
filename <- system.file("ex/lux.shp", package="terra")
basename(filename)
```

```{r}
#| echo: true

# install.packages("geodata")
library(geodata)
arg <- gadm("ARG", level = 1, path = ".")
arg
```

## Escribir ficheros vectoriales

```{r}
#| echo: true
writeVector(arg, "arg.shp", overwrite=TRUE)
```

# Manejando datos raster

## Crear datos raster

```{r}
#| echo: true
r <- rast(ncol=10, nrow=10, xmin=-150, xmax=-80, ymin=20, ymax=60)
r
```

```{r}
#| echo: true
values(r) <- runif(ncell(r))
r
```

```{r}
#| echo: true
values(r) <- 1:ncell(r)
r
```

## Graficar datos raster

```{r}
#| echo: true
plot(r)
```

## Añadir información vectorial sobre el gráfico

```{r}
#| echo: true
plot(r)
points(pts, col="red", pch=20, cex=3)
lines(pols, col="blue", lwd=2)
```

## Operar con datos raster

```{r}
#| echo: true
r2 <- r * r
r3  <- sqrt(r)
```

## Combinar raster para crear un objeto multicapa

```{r}
#| echo: true
stck <- c(r, r2, r3)
stck
```

## Graficar datos multicapa

```{r}
#| echo: true
plot(stck)
```

## Extraer capas sueltas de objetos multicapa

```{r}
#| echo: true
r2 <- stck[[2]]
r2
```

## Cargar datos raster

```{r}
#| echo: true
f <- system.file("ex/logo.tif", package="terra")
basename(f)
```

```{r}
#| echo: true
r <- rast(f)
r
```

## Escribir fichero de datos raster

```{r}
#| echo: true
x <- writeRaster(r[[2]], "test_output.tif", overwrite=TRUE)
x
```

# Proyecciones

## Comprobamos el CRS de alguno de nuestros datos

```{r}
#| echo: true
crs(arg)
```

## Se puede borrar el CRS del conjunto de datos

```{r}
#| echo: true
pp <- arg
crs(pp) <- ""
crs(pp)
```

## O se puede especificar a mano (estandar PROJ.4)

```{r}
#| echo: true
crs(pp) <- "+proj=longlat +datum=WGS84"
crs(pp)
```

## O se puede especificar con los códigos EPSG

```{r}
#| echo: true
crs(pp) <- "EPSG:4326"
crs(pp)
```

## Notad que eso cambia el sistema de referencia pero no las coordenadas en si

```{r}
#| echo: true
par(mfrow = c(1, 2))
plot(arg)
plot(pp)
```

## Si queremos convertir coordenadas entre CRS tenemos que proyectar los datos

```{r}
#| echo: true
newcrs <- "+proj=robin +datum=WGS84"

arg_rob <- terra::project(arg, newcrs)

arg_4326 <- terra::project(arg_rob, "EPSG:4326")
par(mfrow=c(1, 3))
plot(arg)
plot(arg_rob)
plot(arg_4326)
```

## También se pueden proyectar datos raster

```{r}
#| echo: true
stck_rob <- terra::project(stck, newcrs)
crs(stck_rob)
```

## Ahora si que las coordenadas aparecen "desplazadas"

```{r}
#| echo: true
par(mfrow = c(1, 2))
plot(stck[[1]])
plot(stck_rob[[1]])
```

::: asides
Notad que los píxeles no tienen un tamaño regular
:::

## Para controlar el número de pixeles y su resolución debemos crear antes una plantilla

```{r}
#| echo: true
x <- rast(stck_rob)
res(x) <- 200000
x
```

```{r}
#| echo: true

stck_rob_2 <- terra::project(stck, x)
stck_rob_2
```

## Veamos el resultado

```{r}
#| echo: true
par(mfrow = c(1, 3))
plot(stck[[2]])
plot(stck_rob[[2]])
plot(stck_rob_2[[2]])
```

# Manipular datos espaciales

plot(arg, "NAME_2")

d \<- as.data.frame(arg) head(d) \## ID_1 NAME_1 ID_2 NAME_2 AREA POP \## 1 1 Diekirch 1 Clervaux 312 18081 \## 2 1 Diekirch 2 Diekirch 218 32543 \## 3 1 Diekirch 3 Redange 259 18664 \## 4 1 Diekirch 4 Vianden 76 5163 \## 5 1 Diekirch 5 Wiltz 263 16735 \## 6 2 Grevenmacher 6 Echternach 188 18899

g \<- geom(arg) head(g)

g \<- geom(arg, wkt=TRUE) substr(g, 1, 50)

arg\$NAME_2

arg\[, "NAME_2"\]

set.seed(0) arg\$lets \<- sample(letters, nrow(arg)) arg

perim(arg) arg\$perimetro \<- perim(arg)

arg\$lets \<- sample(LETTERS, nrow(arg)) head(arg)

arg\$lets \<- NULL

dfr \<- data.frame(District = arg$NAME_1, Canton = arg$NAME_2, Value = round(runif(length(arg), 100, 1000))) dfr \<- dfr\[order(dfr\$Canton), \] pm \<- merge(arg, dfr, by.x = c('NAME_1', 'NAME_2'), by.y = c('District', 'Canton')) pm

head(pm)

i \<- which(p\$NAME_1 == 'Grevenmacher') g \<- p\[i,\] g

z \<- rast(p) dim(z) \<- c(2,2) values(z) \<- 1:4 names(z) \<- 'Zone'

z \<- as.polygons(z) z

z2 \<- z\[2,\] plot(p) plot(z, add=TRUE, border='blue', lwd=5) plot(z2, add=TRUE, border='red', lwd=2, col='red')

b \<- rbind(p, z) head(b)

tail(b)

pa \<- aggregate(p, by='NAME_1') za \<- aggregate(z) plot(za, col='light gray', border='light gray', lwd=5) plot(pa, add=TRUE, col=rainbow(3), lwd=3, border='white')

e \<- erase(p, z2) plot(e)

i \<- intersect(p, z2) plot(i)

e \<- ext(6, 6.4, 49.7, 50) pe \<- crop(p, z2) plot(p) plot(e, add=TRUE, lwd=3, col="red") plot(i, col='light green', add=TRUE) plot(pe, col='light blue', add=TRUE) plot(e, add=TRUE, lwd=3, border="blue")

u \<- union(p, z) u

set.seed(5) plot(u, col=sample(rainbow(length(u))))

dif \<- symdif(z,p) plot(dif, col=rainbow(length(dif)))

extract(spts, p)

extract(spts, z)
