---
title: "Análisis de datos espaciales en R"
subtitle: "Manejo de datos espaciales en R"
author: "Diego Nieto Lugilde"
institute: "Universidad de Córdoba (España)"
slide-number: true
format:
  revealjs:
    logo: img/logos.png
    footer: "[AEMeR](https://dnietolugilde.com/AEMeR)"
    scrollable: true
    theme: dark
editor: source
---

# Manejando datos espaciales

## Para ello usaremos el paquete Terra

```{r}
#| echo: true
library(terra)
```

# Manejando datos vectoriales

## Crear datos vectoriales desde cero

```{r}
#| echo: true
#| code-line-numbers: '1-2|3|4-5'
lon <- c(-116.7, -120.4, -116.7, -113.5, -115.5, -120.8, -119.5, -113.7, -113.7, -110.7) 
lat <- c(45.3, 42.6, 38.9, 42.1, 35.7, 38.9, 36.2, 39, 41.6, 36.9) 
lonlat <- cbind(lon, lat) 
pts <- vect(lonlat) 
pts
```

::: aside
Fijaros que el apartado "coord. ref." está vacío.
:::

## Revisamos el tipo de datos

```{r}
#| echo: true
class (pts)
```

```{r}
#| echo: true
geom(pts)
```

## Visualizamos la distribución espacial de los datos

```{r}
#| echo: true
plot(pts)
```

## Establecemos el sistema de referencia de coordenadas (CRS)

```{r}
#| echo: true
crdref <- "+proj=longlat +datum=WGS84"
pts <- vect(lonlat, crs = crdref)
pts
```

## Podemos comprobar sólo el CRS de un archivo vectorial

```{r}
#| echo: true
crs(pts)
```

## La ubicación sola no es muy interesante...

Vamos a simular valores de precipitación al azar, un valor para cada punto.

```{r}
#| echo: true
precipvalue <- sample(1:100, 10)
df <- data.frame(ID = 1:nrow(lonlat), precip = precipvalue)
pts <- vect(lonlat, atts = df, crs = crdref)
pts
```

## Visualizamos las precipitaciones en su contexto espacial

```{r}
#| echo: true
plot(pts, "precip", type = "interval")
```

## Vamos a generar ahora un segundo conjunto de puntos...

```{r}
#| echo: true
lon2 <- c(-116.8, -114.2, -112.9, -111.9, -114.2, -115.4, -117.7)
lat2 <- c(41.3, 42.9, 42.4, 39.8, 37.6, 38.3, 37.6)
lonlat2 <- cbind(id = c(1,1,1,1,1,1,1), part = c(1,1,1,1,1,1,1), lon2, lat2)
lonlat2
```

## ... pero para crear datos vectoriales de líneas...

```{r}
#| echo: true
lns <- vect(lonlat2, type = "lines", crs = crdref)
lns
```

```{r}
#| echo: true
plot(lns)
```

## ... o un datos vectoriales de polígonos.

```{r}
#| echo: true
pols <- vect(lonlat2, type = "polygons", crs = crdref)
pols
```

```{r}
#| echo: true
plot(pols)
```

## Lo más normal es usar datos generados con un SIG.

Podemos descargar datos de internet (v.gr. [GADM](https://gadm.org)) y cargarlos desde nuestro disco duro.

```{r}
#| echo: true
#| eval: false

# install.packages("geodata")
arg <- vect("gadm/gadm41_ARG_1.shp")
arg
```

## Lo más normal es usar datos generados con un SIG.

Pero hay paquetes que dan acceso a datos vectoriales directamente en R (v.gr. `geodata`)

```{r}
#| echo: true

# install.packages("geodata")
library(geodata)
arg <- gadm("ARG", level = 1, path = ".")
arg
```

## Veamos si se parece a lo que conocemos...

```{r}
#| echo: true

plot(arg)
```

## Si quieres guardar esos datos para no tener que volver a descargarlos, puedes escribir ficheros vectoriales

```{r}
#| echo: true
#| eval: false

writeVector(arg, "arg.shp", overwrite = TRUE)
```

## Comprobamos el CRS de alguno de nuestros datos

```{r}
#| echo: true
crs(arg)
```

## Se puede borrar el CRS del conjunto de datos

```{r}
#| echo: true
arg_sin_crs <- arg
crs(arg_sin_crs) <- ""
crs(arg_sin_crs)
```

## O se puede especificar a mano (estandar PROJ.4)

```{r}
#| echo: true

arg_falso_utm <- arg
crs(arg_falso_utm) <- "+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs +type=crs"
crs(arg_falso_utm)
```

## O se puede especificar con los códigos [EPSG](https://epsg.io/)

```{r}
#| echo: true
arg_false_utm2 <- arg
crs(arg_false_utm2) <- "EPSG:32719"
crs(arg_false_utm2)
```

## Notad que eso cambia el sistema de referencia pero no las coordenadas en si

```{r}
#| echo: true
par(mfrow = c(2, 2))
plot(arg)
plot(arg_sin_crs)
plot(arg_falso_utm)
plot(arg_false_utm2)
```

## Si queremos convertir coordenadas entre CRS tenemos que proyectar los datos

```{r}
#| echo: true

arg_utm19s <- project(arg, "+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs +type=crs")

arg_4326 <- project(arg, "EPSG:32719")
par(mfrow = c(1, 3))
plot(arg)
plot(arg_utm19s)
plot(arg_4326)
```

## Momento para practicar

Ejercicios de clase

Parte 1: Trabajando con datos vectoriales

# Manejando datos raster

## Crear datos raster

```{r}
#| echo: true
r <- rast(ncol = 10, nrow = 10, 
          xmin = -150, xmax = -80, 
          ymin = 20, ymax = 60)
r
```

```{r}
#| echo: true
values(r) <- runif(ncell(r))
r
```

## Graficar datos raster

```{r}
#| echo: true
plot(r)
```

## Añadir información vectorial sobre el gráfico

```{r}
#| echo: true
plot(r)
plot(pols, border = "blue", lwd = 2, add = TRUE)
plot(pts, col = "red", pch=20, cex=1, add = TRUE)
```

## Operar con datos raster

```{r}
#| echo: true
r2 <- r * r
r3  <- sqrt(r)
```

## Combinar raster para crear un objeto multicapa

```{r}
#| echo: true
stck <- c(r, r2, r3)
stck
```

## Graficar datos multicapa

```{r}
#| echo: true
plot(stck)
```

## Extraer capas sueltas de objetos multicapa

```{r}
#| echo: true
r2 <- stck[[2]]
r2
```

## Como con datos vectoriales, lo normal es cargar datos ya generados en SIG.

Para ello podemos descargar datos de distintas fuentes (v.gr. [WorldClim](https://worldclim.org))...

```{r}
#| echo: true

tavg <- rast("tavg_arg.tif")
tavg
```

## ... o podemos usar el paquete `geodata` para acceder directamente a esa información
```{r}
#| echo: true
#| eval: false

tavg <- worldclim_country("ARG", "tavg", path = ".")
tavg
```

## Veamos si se parece a lo que conocemos...

```{r}
#| echo: true
plot(tavg)
```

## Si queremos reutilizar los datos y no tener que volver a descargarlos, también podemos escribirlos en un fichero de datos raster

```{r}
#| echo: true
#| eval: false
writeRaster(tavg_arg.tif, "raster_tavg_arg.tif", overwrite = TRUE)
```

## También se pueden proyectar datos raster

```{r}
#| echo: true
#| 
tavg_utm19s <- project(tavg, "EPSG:32719")
tavg_utm19s
```

## Ahora si que las coordenadas aparecen "desplazadas"

```{r}
#| echo: true
par(mfrow = c(1, 2))
plot(tavg[[1]])
plot(tavg_utm19s[[1]])
```

::: asides
Notad que no hay una correspondencia exacta de píxeles. 
:::

## Para controlar el número de pixeles y su resolución lo normal es crear antes una plantilla

```{r}
#| echo: true
x <- rast(tavg_utm19s)
res(x) <- 800
x
```

```{r}
#| echo: true

tavg_utm19s_2 <- project(tavg, x)
tavg_utm19s_2
```

## Veamos el resultado

```{r}
#| echo: true
par(mfrow = c(1, 3))
plot(tavg[[2]])
plot(tavg_utm19s[[2]])
plot(tavg_utm19s_2[[2]])
```

```{r}
#| echo: true
tavg[[2]]
tavg_utm19s[[2]]
tavg_utm19s_2[[2]]
```

## Momento de practicar por vuestra cuenta

Ejercicios de clase

Parte 2. Manejo de datos raster

# Manipular datos espaciales

## Podemos dibujar los mapas con colores en base a alguna información de los atributos.

```{r}
#| echo: true
plot(arg, "NAME_1")
```

## También se puede extraer la información de los atributos en formato `data.frame` para trabajar con ella de forma estadística.

```{r}
#| echo: true
d <- as.data.frame(arg)
head(d)
```

## O puedo extraer la información de un sólo campo de los atributos.

```{r}
#| echo: true
arg$NAME_1
arg[, "NAME_1"]
```

::: asides
Notad que en este caso, las dos formas de extraer información no se comportan exactamente igual.
:::

## También podemos extraer las características geográficas (espaciales)

```{r}
#| echo: true
g <- geom(arg_utm19s) 
head(g)
```

## A veces, necesitamos incorporar información a nuestros datos vectoriales.

```{r}
#| echo: true
arg_utm19s$lets <- sample(letters, nrow(arg_utm19s)) 
arg_utm19s
```

```{r}
#| echo: true
perim(arg_utm19s)
arg_utm19s$perimetro <- perim(arg_utm19s)
```

```{r}
#| echo: true
expanse(arg_utm19s)
arg_utm19s$area <- expanse(arg_utm19s)
```

## ¿Qué pasa si quiero borrar una columna?

```{r}
#| echo: true
arg$lets <- NULL
```

## A veces tenemos los datos en una tabla aparte. Podemos vincularla con los datos de los atributos vectoriales, pero necesitamos un campo en común.

Me descargué datos del [censo poblacional del país](https://censo.gob.ar/index.php/datos_definitivos_total_pais/) 

```{r}
#| echo: true
d <- read.csv("data/c2022_tp_c_resumen.csv", header = TRUE, encoding = "latin1")
arg_pop <- merge(arg, d, by.x = 'NAME_1', by.y = 'provincia')
arg_pop
```

## Veamos como se ve la población argentina por provincias...

```{r}
#| echo: true
plot(arg_pop, "poblacion", type = "continuous")
```

## También se puede filtrar la información para una o varias entidades dentro de los datos.

```{r}
#| echo: true
which(arg_pop$NAME_1 == 'Buenos Aires')
i <- which(arg_pop$NAME_1 %in% c("Buenos Aires", "Río Negro"))
g <- arg_pop[i,]
plot(g)
```


z <- rast(p) dim(z) <- c(2,2) values(z) <- 1:4 names(z) <- 'Zone'

z <- as.polygons(z) z

z2 <- z[2,] plot(p) plot(z, add = TRUE, border = 'blue', lwd = 5) plot(z2, add = TRUE, border = 'red', lwd = 2, col = 'red')

b <- rbind(p, z) head(b)

tail(b)

pa <- aggregate(p, by = 'NAME_1') za <- aggregate(z) plot(za, col = 'light gray', border = 'light gray', lwd = 5) plot(pa, add = TRUE, col = rainbow(3), lwd = 3, border = 'white')

e <- erase(p, z2) plot(e)

i <- intersect(p, z2) plot(i)

e <- ext(6, 6.4, 49.7, 50) pe <- crop(p, z2) plot(p) plot(e, add = TRUE, lwd = 3, col = "red") plot(i, col = 'light green', add = TRUE) plot(pe, col = 'light blue', add = TRUE) plot(e, add = TRUE, lwd = 3, border = "blue")

u <- union(p, z) u

set.seed(5) plot(u, col = sample(rainbow(length(u))))

dif <- symdif(z,p) plot(dif, col = rainbow(length(dif)))

extract(spts, p)

extract(spts, z)
